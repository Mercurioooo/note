# 复习指南总结

操作系统

1. 题型:九道大题[4道简答题(概念) ] [编程题(能读懂) ] [设计任务]
2. 关注平时作业

3. 重点:
   - 虚拟化
     - 分段分页优缺点
     - 分页(地址翻译过程，访问，页表组织)
     - 多级页表(掌握整个处理流程)
     - 虚拟页物理页对应关系
     - 缓存替换策略(随机、LRU)
     - 进程并发
     - 同步问题(死锁、顺序问题)、进程调度、 多核调度
   - 并发:
     - 锁(CAS)、条件变量、信号量(读者写者，生产者消费者)
     - 线程操作函数(pthread库 (等待，加锁) ) ! (补写代码)
   - 持久性重点: 
     - raid性能分析总结(可靠性，吞吐量! (337页) )
     - 磁盘分区调度算法、磁盘寻道旋转时间!
     - 文件系统(元数据，真实数据管理，几读几写)





![image-20200104142150921](/Users/dylan/Library/Application Support/typora-user-images/image-20200104142150921.png)

### CPU 调度算法

1. 先到先服务FCFS
   最短作业优先SJF
   轮转RR

   >7.2调度指标  `周转= 完成 - 到达`
   >7.3先进先出(FIFO) ` 先到先服务,如果时间长的先到达周转就不行了`
   >7.4最短任务优先(SJF). `如果一个长时间的任务正在运行别的短的来了没办法`
   >7.5最短完成时间优先(STCF)  `这个可以抢占`
   >7.6新度量指标:响应时间 `响应时间 = 首次运行 - 到达时间`
   >7.7轮转`换着来执行,但如果时间片太短上下文切换的成本太高`
   >7.8结合I/O  `在别的进程执行IO的时候就可以重叠做事情了`
   >7.9无法预知  `实际上每一个工作的长度是无法预知的`
   >7.10小结 `为了保证周转时间:优先运行最短的工作。 为了保证响应时间:交替运行`

   多级反馈队列

   >调度的最终目标:1.优化周转时间2.降低响应时间:给用户很好的交互体验
   >8.1 MLFQ:基本规则:优先级:1⃣️a>b,a 2⃣️a==b 换着来
   >8.2尝试1:如何改变优先级  3⃣️刚进系统的,放上面 4⃣️ i.用完时间片降低优先级// ii.主动放弃保持不变
   >8.3尝试2:提升优先级  5⃣️经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。(不会饿死)
   >8.4尝试3:更好的计时方式。 改变4⃣️用完了就降低优先级.(无论中间主动放弃了多少次 CPU)，
   >8.5 MLFQ调优及其他问题

   多处理器调度的特殊性:

   - 硬件缓存一致性

   - 多个cpu访问同一个数据的时候需要加锁

   - 缓存亲和度

     > 尽可能将进程保持在同一个 CPU,一个进程在某个 CPU 上运行时，会在该 CPU 的缓存中维护许多状态。下次 该进程在相同 CPU 上运行时，由于缓存中的数据而执行得更快。相反，在不同的 CPU 上执 行，会由于需要重新加载数据而很慢

2. 进程和线程的概念

   >进程：是执行中一段程序，是调度运行的基本单位，
   >
   >线程：线程是进程的一个实体,是比进程更小的能独立运行的基本单位

   相关编程接口:

    fork,exec,wait,phread_create,pthread_join

3. 同步相关概念
   死锁:

   > *死锁*是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。这些永远在互相等待的进程称为*死锁*进程。

   活锁:

   > *活锁*指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程。处于*活锁*的实体是在不断的改变状态，*活锁*有可能自行解开。

   Phread库中的相关同步函数:

   TBC

4. 地址空间的概念:

   > 这个抽象叫作地址空间(address space)，是运行的程序看到的系统中的内存。`
   >
   > 一个进程的地址空间包含运行的程序的所有内存状态:代码+栈+堆
   >
   > 1.程序的代码(code，指令)必须在内存中，因此它们在地址空间里。
   > 2.当程序在运行的时候，利用栈(stack)来保存当前的函数调用信息，分配空间给局部变量，传递参数和函数返回值。
   > 3.堆(heap)用于管理动态分配的、用户管理的内存
   > ![image-20200103153713466](/Users/dylan/Library/Application Support/typora-user-images/image-20200103153713466.png)

   用户态堆内存的管理
   TBC

5. 锁、条件变量、信号量解决生产者消费者(可以最后一天再看)

   锁:

   比较并交换CAS。compare and swap(这一大段唯一有可能涉及的)

   ```c
   typedef struct lock_t {int flag} lock_t;
   void init(lock_t *lock) {lock -> flag = 0;}
   void lock(lock_t * lock){while(CompareAndSwap(&lock->flag,0,1)==1) ;}
   void unlock(lock_t * lock) {lock->flag=0;}
   
   int CompareAndSwap(int *ptr,int expected,int new){
   	int actual = *ptr;
     if(actual == expected)
       	*ptr = new;
     return actual;
   }
   ```

   条件变量:

   ```c
   int buffer[MAX];
   int fill = 0;
   int use = 0;//?
   int count = 0;
   
   void put(int value){
   	buffer[fill] = value;
   	fill = (fill+1)%MAX;
   	count++;
   }
   
   int get(){
   	int tmp = buffer[use];
     use = (use+1)%MAX;
     count--;
     return tmp;
   }
   
   cond_t empty,fill;
   mutex_t mutex;
   void *producer(void *arg){
   	int i;
     for(int i = 0; i < loops; i++){
       //锁起来 等着(wait)空了(empty)放进去,通知(notify)一下满了fill
       Phread_mutex_lock(mutex);
       /*-----------------------*/
       while(count == MAX)
         Pthread_cond_wait(&empty,&mutex);//为什么是empty
       put(i);
       Phread_cond_notify(&fill,&mutex);
       /*-----------------------*/
       Phread_mutex_unlock(&mutex);
     }
   }
   
   void *consumer(void * arg){
     int i;
     for(i = 0;i < loops;i++){
       Phread_mutex_lock(&mutex);
       /*-----------------------*/
       while(count == 0)
         Phread_cond_wait(&fill,&mutex);//只要是fill变化就醒来
       int tmp = get();
       Phread_cond_notify(&empty,&mutex);
       /*-----------------------*/
       Phread_mutex_unlock();
   	}
   }
   ```

   信号量:

   ```c
   int buffer[MAX];
   int fill = 0;
   int use = 0;
   
   void put(int value){
   	buffer[fill] = value;
     fill = (fill+1)%MAX;
   }
   
   int get(){
   	int tmp = buffer[use];
     use = (use+1)%MAX;
     return tmp;
   }
   sem_t empty,full,mutex;
   void *producer(void *arg){
   	int i;
     for(i = 0 ; i < loops; i++){
       sem_wait(&empty);
       sem_wait(&mutex);/**///等于是缩小了锁的范围
       put(i);
       sem_post(&mutex);/**/
       sem_post(&full);
     }
   }
   void *consumer(void *arg){
   	int i;
     for(i = 0; i < loops;i++){
       sem_wait(&full);
       sem_wait(&mutex);/**/
       int tmp = get();
       sem_post(&mutex);/**/
       sem_post(&empty);
     }
   }
   ```

   

6. 分段与分页机制的原理，以及比较其优缺点

   > **分段:**
   > 一个段是 地址空间里的一个连续定长的区域，在典型的地址空间里有 3 个逻辑不同的段:代码、栈 和堆,分别有一个基址和界限寄存器对，分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。
   > 优点:
   > 1.帮助我们实现了更高效的虚拟内存,能更好地支持稀疏地址空间
   > 2.很快，因为分段要求的算法很容易，很适合硬件完成，地址转换的开销极小
   > 3.代码共享。如果代码放在独立的段中，这样的段就可能被多个运行的程序共享。
   > 缺点:
   > 1.外部碎片:由于段的大小不同，空闲内存被割裂成各种奇怪的大小，因此满足内存分配请求可能会很难
   > 2.还是不足以支持更一般化的稀疏地址空间。如果有一个很大但是稀疏的堆，都在一个逻辑段中，整个堆仍然必须完整地加载到内存中。
   >
   > **分页:**
   >
   > 将空间分割成固定长度的分片。分页不是将一个进 程的地址空间分割成几个不同长度的逻辑段(即代码、堆、段)，而是分割成固定大小的单 元，每个单元称为一页。相应地，我们把物理内存看成是定长槽块的阵列，叫作页帧(page frame)。每个这样的页帧包含一个虚拟内存页。
   >
   > 优点:
   > 1.首先，它不会导致外部碎片
   > 2.灵活性: 通过完善的分页方法，不管进程如何使用地址空间,操作系统能够高效地􏶉供地址空间的抽象。
   > 3.简单性。例如，如果操作系统希望将 64 字节 的小地址空间放到 8 页的物理地址空间中，它只要找到 4 个空闲页。也许操作系统保存了 一个所有空闲页的空闲列表(free list)，只需要从这个列表中拿出 4 个空闲页。

7. TLB与多级页表


   多级页表相关的计算，根据地址位、页面大小、PTE大小等条件，进行虚拟地址到物理地址的转换;掌握多级页表的访问过程。

8. 页面置换算法FIFO,LRU这个很好搞

   掌握clock算法

   > 硬件增加一个使用位,每当页被引用(即读或写)时，硬件将使用位设置为 1。
   > 系统中的所有页都放在一个循环列表中。时 钟指针(clock hand)开始时指向某个特定的页(哪个页不重要)。当必须进行页替换时，操 作系统检查当前指向的页 P 的使用位是 1 还是 0。如果是 1，则意味着页面 P 最近被使用， 因此不适合被替换。然后，P 的使用位设置为 0，时钟指针递增到下一页(P + 1)。该算法 一直持续到找到一个使用位为 0 的页，使用位为 0 意味着这个页最近没有被使用过(在最 坏的情况下，所有的页都已经被使用了，那么就将所有页的使用位都设置为 0)。

9. 寻道+旋转+传输时间
   计算过程:就直接加起来就行了呗
   <img src="/Users/dylan/Library/Application Support/typora-user-images/image-20200104113211397.png" alt="image-20200104113211397" style="%;" />

10. 磁盘调度算法:

    > SSTF:最短寻道时间优先shortest seek time first.  缺点:不知道几何结构,导致饥饿
    >
    > scan&C-scan
    >
    > SCAN算法:先按照一个方向(比如从外向内扫描)，扫描的过程中依次访问要求服务的序列。当扫描到最里层的一个服务序列时反向扫描，
    > 这里要注意，假设最里层为0号磁道，最里面的一个要求服务的序列是5号，访问完5号之后，就反向了，不需要再往里扫。结合电梯过程更好理解，在电梯往下接人的时候，明知道最下面一层是没有人的，它是不会再往下走的。
    >
    > CSCAN算法，循环扫描算法，访问完最里面一个要求服务的序列之后，立即回到最外层欲访问磁道。也就是始终保持一个方向。故也称之为单向扫描调度算法。从最里面的一个磁道立即回到最外层欲访问的磁道，这步的距离是两者磁道号差的绝对值。

11. 磁盘阵列raid0,1,4,5的原理

    |              | Raid0  | Raid1                    | Raid4                                         | Raid5        |
    | ------------ | ------ | ------------------------ | --------------------------------------------- | ------------ |
    | 定义         | 条带化 | 镜像                     | 奇偶校验(加法&减法)<br />每一位上执行按位异或 | 旋转奇偶校验 |
    | 容量         | ✅      | 一半                     | N-1                                           | N-1          |
    | 可靠性       | ❌      | ✅                        | 允许一个故障                                  | 一个故障     |
    | 吞吐量(顺序) | N*S    | 读写:(N/2)*S             | 读写:(N-1)*S(全条带写入)                      | 读写:(N-1)*S |
    | 吞吐量(随机) | N*R    | 读:N*R<br />写:(N/2) * R | 读:(N-1)*R<br />写:(R / 2) * N                | (N/4) ·R     |

    [其中N代表磁盘数量,S:单个磁盘的顺序带宽,R:单个磁盘的随机带宽]
    单请求延迟:了解单个 I/O 请求对 RAID 的满意度非常有用，因为它可以揭示单个逻辑 I/O 操作期间可以存在多少 并行性。
    稳态吞吐量:即许多并发请求的总带宽。由于 RAID 常用于高性能环境，因此稳态带宽至关重要，因此将成为我们分析的主要重点。

    > 单请求延迟是真的搞不懂感觉也不会考,直接粘贴到这里,随缘吧:
    >
    > 1. raid0
    >    例如，从延迟角度来看，单块请求的延迟应该与单个磁盘的延迟几乎相同。毕竟，RAID-0 将简单地将该请 求重定向到其磁盘之一。
    >
    > 2. raid1
    >
    >    从单个读取请求的延迟角度来看，我们可以看到它与单个磁盘 上的延迟相同。所有 RAID-1 都会将读取导向一个副本。写入有点不同:在完成写入之前， 需要完成两次物理写入。这两个写入并行发生，因此时间大致等于单次写入的时间。然而， 因为逻辑写入必须等待两个物理写入完成，所以它遭遇到两个请求中最差的寻道和旋转延 迟，因此(平均而言)比写入单个磁盘略高。
    >
    > 3. raid4
    >
    > 4. Raid5

    

    > 另外提一下Raid4的写入问题:
    >
    > 减法奇偶校验:
    >
    > <img src="/Users/dylan/Library/Application Support/typora-user-images/image-20200104121054387.png" alt="image-20200104121054387" style="zoom:80%;" />
    >
    > <img src="/Users/dylan/Library/Application Support/typora-user-images/image-20200104121713743.png" alt="image-20200104121713743" style="zoom:67%;" />
    > 这两个请求都必须读取 4 和 13 的奇偶校验块，本来打算并行写的,但是都要修改磁盘4,所以写操作基本被序列化了
    >
    > (一次读取，一次写入)，我们可以通过计算奇偶校验磁盘在这两个 I/O 上的性能来计算 RAID-4 中的小的随机写入的性能，从而得到(R / 2)MB/s。随机小写入下的 RAID-4 吞吐 量很糟糕，向系统添加磁盘也不会改善
    >
    > 

    

    ![image-20200104113414726](/Users/dylan/Library/Application Support/typora-user-images/image-20200104113414726.png)

    ![image-20200104113402219](/Users/dylan/Library/Application Support/typora-user-images/image-20200104113402219.png)

    ![image-20200104115949177](/Users/dylan/Library/Application Support/typora-user-images/image-20200104115949177.png)

12. open()，read，write，在实现时对元数据和文件内容的读写过程

    - Open:

      - 发起系统调用open,传入文件路径

      - 根据文件路径去找对应的inode编号
        “/home/user/test.txt”根目录的默认inode号是约定的2,去inode table里面找到根目录的inode信息,根据inode读取磁盘扇区获取文件内容

        ```c
        //这里是inode指向的数据块中 根目录中的文件内容
        //后面的编号是文件的inode号,然后继续查找inode为3的文件内容,直到最后找到了test.txt
         home 3     
         etc 4
         bin 5
         eg.txt 5
        ```

      - 获取inode之后,os生成一个文件描述符,存储在进程p的file descriptor 数据结构中

    - Read:  文件描述符->inode->文件在磁盘的哪些扇区中,读取扇区

    - write:
      创建部分:(“root/foo/bar”)

      1. 读取root inode 并查看root的内容 找到foo的inode
      2. 读取foo inode 并查看foo的内容
      3. 查看inode位图,找到空闲的inode位置(用于存放bar的inode)
      4. 把“bar inode”写入foo
      5. 写入inode位图,把用于存放bar inode的位置标记为1
      6. 读取bar的inode
      7. 并把bar的相关信息(元数据)写入inode
      8. ???不懂为什么要写入foo的inode,嗷我知道了,要写入最后修改时间

      写入部分:

      1. 读取inode
      2. 读取bit map找空闲的位置

      3. 写入数据到空闲位置
      4. 写入bit map为1
      5. 写入bit node

    ```c
    fd = create(filename,"权限")
    read(filename/"文件描述符",buffer,size) 
    write(filname/fd,buffer,size)
    off_t lseek(fd,offset,"搜索的执行方式")  //读取和写入，但不按顺序 
    fsync(fd)  		                         //立即写入,强制将所有脏(dirty)数据写入磁盘
    rename(char * old, char * new)         //文件重命名,通常是原子的
    stat()																 //元数据:关于文件的信息.....填充一个stat结构(有文件信息)
    unlink("文件名")											   //删除文件(硬链接)
    /*******/
    mkdir("目录名",0777);									 //    ls -a可以查看隐藏目录.和..  --a可以查看权限
    opendir();
    readdir();
    closedir();
    rmdir();
    /*******/
    link("旧路径名","新路径名");					//$ln file file2
    ```

    







1. 掌握进程和线程的概念，熟练使用进程和线程相关编程接口，如 fork，exec，wait， pthread_create，pthread_join 等。

2. 掌握进程并发同步相关概念，如死锁、活锁等概念，真实应用中存在的不同类型的同步 问题，熟练使用 pthread 库中的相关同步函数进行编程。

3. 掌握地址空间的概念，以及用户态堆内存的管理。

4. 掌握锁、条件变量、信号量三种同步机制(熟练使用pthread库中的函数)，并使用这些

   ```
     机制解决实际应用问题，如生产者消费者问题。
   ```

5. 掌握虚拟内存管理中的分段与分页机制的原理，以及比较其优缺点。

6. 掌握TLB与多级页表，掌握多级页表相关的计算，比如根据地址位、页面大小、PTE大

   小等条件，进行虚拟地址到物理地址的转换;掌握多级页表的访问过程。

7. 掌握页面置换算法，比如FIFO，LRU等，要求能根据给定的页面访问序列，给出特定算

   法的计算过程;掌握 CLOCK 算法。

8. 掌握磁盘寻道、旋转、传输时间的概念及计算过程。

9. 了解各种磁盘调度算法的原理。

10. 掌握磁盘阵列 RAID-0，RAID-1，RAID-4，RAID-5 的原理，并分析各种 RAID 在容量、可

    靠性、吞吐量三个层面的特性。熟练使用 RAID 的这些特性进行设计。

11. 了解文件系统接口，如 open，read，write，在实现时对元数据和文件内容的读写过程。

12. 了解课堂上讲到的跟操作系统发展史相关的重要人物，并能介绍其主要贡献。

13. 作业中的难点问题需要掌握其解题方法。

# 作业总结:

## 第一部分

### 4

cpu利用率的百分比





# 试卷总结

1. 调度

   - 执行时间图描述执行情况
   - 周转时间(),平均周转时间

2. 内存溢出攻击与防御

   - 栈溢出攻击原理
   - 构造栈溢出攻击并画出进程运行时栈
   - 三种主要的内存溢出攻击的防御方法的原理

3. - 为什么要提供地址空间的抽象
   - 分析代码错误

4.  1，2，3，4，1，2，5，1，2，3， 4，5

   - 物理内存块为3和4时，FIFO、LRU置换缺页次数?

     > FIFO:
     >
     > | 访问页面 | 3是否命中 | 3内存内容 | 4是否命中 | 4内存内容 |
     > | -------- | --------- | --------- | --------- | --------- |
     > | 1        | x         | 1         | x         | 1         |
     > | 2        | x         | 12        | x         | 12        |
     > | 3        | x         | 123       | x         | 123       |
     > | 4        | x         | 234       | x         | 1234      |
     > | 1        | x         | 341       | o         | 1234      |
     > | 2        | x         | 412       | o         | 1234      |
     > | 5        | x         | 125       | x         | 2345      |
     > | 1        | o         | 125       | x         | 3451      |
     > | 2        | o         | 125       | x         | 4512      |
     > | 3        | x         | 253       | x         | 5123      |
     > | 4        | x         | 534       | x         | 1234      |
     > | 5        | o         | 534       | x         | 2345      |
     >
     > LRU:
     >
     > | 访问页面 | 3是否命中 | 3内存内容 | 4是否命中 | 4内存内容 |
     > | -------- | --------- | --------- | --------- | --------- |
     > | 1        | x         | 1         | x         | 1         |
     > | 2        | x         | 12        | x         | 12        |
     > | 3        | x         | 123       | x         | 123       |
     > | 4        | x         | 234       | x         | 1234      |
     > | 1        | x         | 341       | o         | 2341      |
     > | 2        | x         | 412       | o         | 3412      |
     > | 5        | x         | 125       | x         | 4125      |
     > | 1        | o         | 251       | o         | 4251      |
     > | 2        | o         | 512       | o         | 4512      |
     > | 3        | x         | 123       | x         | 5123      |
     > | 4        | x         | 234       | x         | 1234      |
     > | 5        | x         | 345       | x         | 2345      |

   - 近似LRU的算法

5.  磁盘调度

   - 描述FCFS、SSTF、C-SCAN

     > FCFS:First Come First Service
     >
     > SSTF:最短寻道时间优先算法Shortest Seek Time First 
     >
     > C-SCAN 循环扫描算法

   - 判断是哪一种磁盘调度算法,画出另外两个

     > 最短寻道时间优先算法
     >
     > 先来先服务很好画,按照顺序画就可以
     >
     >  循环扫描注意一下是到头了之后直接跳到另一头,另外必须按照顺序来
     >
     > <img src="/Users/dylan/Library/Application Support/typora-user-images/image-20200103103559903.png" alt="image-20200103103559903" style="float:left;zoom:67%;" />

6.  读s mb/s ,写R MB/s,raid4和raid5的吞吐率

7. 元数据:

   - inode的作用,包含的信息(必考)

     > 
     >
     > 保存一些用于描述文件的信息
     >
     > 文件的大小,引用个数,最后的修改时间,文件头,....
     >
     > 

   - 包含间接指针的大小

     > 10 * 1024+1*1024^2
     >
     >  1024 * 1024 * 1024

8. 操作系统发展史

